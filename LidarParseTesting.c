#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate250000, IOPins, None, None)
#pragma config(Motor,  port10,          lidarMotor,    tmotorVex269_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

union float2bytes { float f; char b[sizeof(float)]; };

#define CORTEXA UART2
#define lidarTimeout 2000

const bool DEBUGTOCORTEXA = false;
const bool RELAYRAWDATA = false;

float2bytes ballCertainty;
short dist[360];
float lidarRPM = 0;
short goalRPM = 295;

#include "lidarHelperTasks.c"
#include "cortexCommunication.c"
#include "XV11_Lib.h"


Ball ballToSend;
char datai[22];

int state = 3;

task main()
{
	setBaudRate(UART1, baudRate115200);
	setBaudRate(CORTEXA, baudRate250000);
	clearComms();
	startTask(cortexCommunication);
	startTask(lidarMotorSpeed);
	startTask(fuckYouBuffer);
	while (true)
	{
		switch (state)
		{
		case 0:
			clearTimer(timer1);
			findClosestBall(ballToSend);
			sendBallToPython(0, ballToSend.angle, ballToSend.mag);
			writeDebugStreamLine("took %d",time1[T1]);
			/*float x;
			float y;
			short mag;
			short angle;
			calculateBallPos(0.0, 0.0, 45.0, 500, 120, &x, &y, &mag, &angle);
			*/
			//writeDebugStreamLine("Angle : %d Dist: %d",ballToSend.angle,ballToSend.mag);
			break;
		case 5:
			//float rpm = getLidarRPM(UART1);
			short dd[5];
			readLidarUART(UART1,dd);
			writeDebugStreamLine("RPM: %1.5f",lidarRPM);
			sleep(1);
			break;
		case 1:            //send raw data over UART1
			stopTask(fuckYouBuffer);
			readLidarRaw(UART1, datai);
			for (int i = 0; i < 22; i++)
			{
				sendChar(UART2, datai[i]);
				writeDebugStreamLine("%X", datai[i]);
			}
			break;
		case 2:       //find balls using findBalls function
			hogCPU();
			getLidarData(UART1, dist);
			filterChassisLidar(dist);
			sleep(10);
			triFilterData tri[15];
			if (triangleFilter(dist, tri, 15, 35))
			{
				/*for(int i = 0; i < 15; i++)
				{
				if(tri[i] != -1)
				writeDebugStreamLine("Angle:%d Dist:%d",tri[i],dist[tri[i]]);
				}*/

				//short ttt = findBall(dist,tri,15,0.022, &certainty);
				//writeDebugStreamLine("Angle:%d Certainty:%1.5f",ttt >= 0 && ttt <= 359 ? ttt : -1,certainty);
			}
			break;

			/**
			*Lidar Cortex will be refered to cortexB and main robot cortex will be refered to as cortexA
			*
			* cortexB waits for requests from cortexA to send appropriate data.
			*
			* <Start> ---> <0xFA>
			*
			* General request packet structure:
			*
			* <Start> <Request>
			*
			* General Packet structure for cortexB:
			* <Start> <Packet Content Identifier> <Data>
			*
			*	Ball Data packet:
			*
			* CortexA requests <0xFB> ---> CortexB
			*	Response:
			*
			* <Start> <Request> [Angle]16bit [Mag]16bit [Certainty]32bit
			*
			*	Position Data packet:
			*
			*	CortexA requests <0xFC> ---> CortexB
			*	Response:
			*
			*	<Start> <Request> [xPosition]32bit [yPosition]32bit [theta]32bit <Reference>       (Reference is what object was used to calculate pos) 15" ---> 0xFE, Goal ---> 0xF9
			*
			*
			*/
		case 3: 			//protocol for cortex to cortex communication
			hogCPU();
			//writeDebugStreamLine("RPM: %1.5f",lidarRPM);
			if (!nothingToSend)
			{
				writeDebugStreamLine("X: %1.5f  Y: %1.5f  Theta: %1.5f",xPos.f,yPos.f,theta.f);
				switch (packetRequestType)
				{

				case T_ball:

					if (findClosestBall(ballToSend))
					{
						angleToSend = ballToSend.angle;
						magToSend = ballToSend.mag;
						ballCertainty.f = 100.0;
						goodDataToSend = true;
					}
					else
					{
						goodDataToSend = true;
						angleToSend = 0;
						magToSend = 0;
						ballCertainty.f = 0.0;
					}

					break;
				case T_pos:

					xPos.f = 0.0;
					yPos.f = 0.0;
					theta.f = 0.0;
					goodDataToSend = true;

					break;

				default:

					break;
				}
			}
			sleep(1);
			break;

		}
	}
}
